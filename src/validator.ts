"use strict";

import { DateRule } from "./rules/DateRule";
import { DifferentRule } from "./rules/DifferentRule";
import { EmailRule } from "./rules/EmailRule";
import { InRule } from "./rules/InRule";
import { IntegerRule } from "./rules/IntegerRule";
import { MaximumRule } from "./rules/MaximumRule";
import { MinimumRule } from "./rules/MinimumRule";
import { PasswordRule } from "./rules/PasswordRule";
import { RequiredRule } from "./rules/RequiredRule";
import { SameRule } from "./rules/SameRule";
import { StringRule } from "./rules/StringRule";

/**
 * Rules for validating an object of values.
 */
export class Validator {
	private rules: object;
	private translations: object;

    /**
     * Instanciate a new validator.
     *
     * @param {Record<string, string>} rules
     *
     * @return {Validator}
     *
     * @example
     * const validator = new Validator({username: "minimum:3"});
     */
    constructor(rules) {
        this.rules = rules;
        this.translations = {};
    }

    /**
     * Customize the error messages generated by the validator.
     *
     * @param {Record<Record<string, string>>} translations
     *
     * @return void
     *
     * @example
     * validator.setTranslations({username: {minimum: "The username is too short."}});
     */
    setTranslations(translations) {
        this.translations = translations;
    }

    /**
     * Return properties that do not match the rules set for the created validator.
     *
     * @param {Record<string, any>} data
     *
     * @return {null|Record<string, string[]>}
     *
     * @example
     * validator.validate({username: "xy"}); // {username: ["The username is too short"]}
     */
    validate(attributes) {
        const {translations} = this;

        const validationErrors = Object.entries(this.rules).reduce((errors, [attributeName, rule]) => {
            const rules = rule.split("|").map(currentRule => currentRule.trim());

            const additionalErrors = rules.reduce((currentErrors, currentRule) => {
                const requiredRule = new RequiredRule({attributeName, attributes, translations});

                if (requiredRule.match(currentRule) && requiredRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            requiredRule.getError()
                        ]
                    };
                }

                const integerRule = new IntegerRule({attributeName, attributes, translations});

                if (integerRule.match(currentRule) && integerRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            integerRule.getError()
                        ]
                    };
                }

                const emailRule = new EmailRule({attributeName, attributes, translations});

                if (emailRule.match(currentRule) && emailRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            emailRule.getError()
                        ]
                    };
                }

                const passwordRule = new PasswordRule({attributeName, attributes, translations});

                if (passwordRule.match(currentRule) && passwordRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            passwordRule.getError()
                        ]
                    };
                }

                const dateRule = new DateRule({attributeName, attributes, translations});

                if (dateRule.match(currentRule) && dateRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            dateRule.getError()
                        ]
                    };
                }

                const stringRule = new StringRule({attributeName, attributes, translations});

                if (stringRule.match(currentRule) && stringRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            stringRule.getError()
                        ]
                    };
                }

                const sameRule = new SameRule({attributeName, attributes, translations});

                if (sameRule.match(currentRule) && sameRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            sameRule.getError()
                        ]
                    };
                }

                const differentRule = new DifferentRule({attributeName, attributes, translations});

                if (differentRule.match(currentRule) && differentRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            differentRule.getError()
                        ]
                    };
                }

                const minimumRule = new MinimumRule({attributeName, attributes, translations});

                if (minimumRule.match(currentRule) && minimumRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            minimumRule.getError()
                        ]
                    };
                }

                const maximumRule = new MaximumRule({attributeName, attributes, translations});

                if (maximumRule.match(currentRule) && maximumRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            maximumRule.getError()
                        ]
                    };
                }

                const inRule = new InRule({attributeName, attributes, translations});
                if (inRule.match(currentRule) && inRule.hasError()) {
                    return {
                        ...currentErrors,
                        [attributeName]: [
                            ...currentErrors[attributeName] || [],
                            inRule.getError()
                        ]
                    };
                }

                return currentErrors;
            }, {});

            return {
                ...errors,
                ...additionalErrors
            };
        }, {});

        if (0 === Object.keys(validationErrors).length) {
            return null;
        }

        return validationErrors;
    }
};
