"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor({attributeName:t,attributes:e,ruleName:r,translations:a}){this.attributeName=t,this.attributes=e,this.translations=a,this.ruleName=r.trim(),this.ruleValue=null,this.error=null}match(t){const[e,r]=t.split(":");return this.ruleName===e&&(void 0!==r&&(this.ruleValue=r.trim()),!0)}hasError(){return this.validate(),null!==this.error}getError(){const{error:t,translations:e,attributeName:r,ruleName:a}=this;return null!==t&&void 0!==e[this.attributeName]&&void 0!==e[r][a]?e[r][a]:t}validate(){}}class e extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"date",translations:r})}validate(){const t=this.attributeName,e=this.attributes[t];null!=e&&Number.isNaN(Date.parse(e))&&(this.error=`${t} should be a valid date.`)}}class r extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"different",translations:r})}validate(){const{attributes:t,attributeName:e,ruleValue:r}=this,a=t[e],s=t[r];null!=a&&a===s&&(this.error=`${e} should not be equal to ${r}.`)}}class a extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"email",translations:r})}validate(){const t=this.attributeName,e=this.attributes[t];"string"!=typeof e||/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/u.test(e)||(this.error=`${t} should be a valid email.`)}}class s extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"in",translations:r})}validate(){const{attributes:t,attributeName:e,ruleValue:r}=this,a=t[e],s=r.split(",").map((t=>t.trim()));null==a||s.includes(a)||(this.error=`${e} should be one of the following: ${s.join(", ")}.`)}}class i extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"integer",translations:r})}validate(){const t=this.attributeName,e=this.attributes[t];Number.isInteger(e)||(this.error=`${t} should be an integer.`)}}class n extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"maximum",translations:r})}validate(){const{attributes:t,attributeName:e,ruleValue:r}=this,a=t[e],s=Number(r);if(null!=a&&!Number.isNaN(s)){if("string"==typeof a&&a.length>s)return void(this.error=`${e} should have at most ${s} characters.`);"number"==typeof a&&a>s&&(this.error=`${e} should be at most equal to ${r}.`)}}}class u extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"minimum",translations:r})}validate(){const{attributes:t,attributeName:e,ruleValue:r}=this,a=t[e],s=Number(r);null==a||Number.isNaN(s)||("string"==typeof a&&a.length<s?this.error=`${e} should have at least ${s} characters.`:"number"==typeof a&&a<s&&(this.error=`${e} should be at least equal to ${r}.`))}}class o extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"password",translations:r})}validate(){const t=this.attributeName,e=this.attributes[t];"string"!=typeof e||/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{8,}/u.test(e)||(this.error=`${t} should contain at least digits, lower & upper letters, symbols and at least 8 characters.`)}}class l extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"required",translations:r})}validate(){const t=this.attributeName,e=this.attributes[t];null==e&&(this.error=`${t} is required.`)}}class b extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"same",translations:r})}validate(){const{attributes:t,attributeName:e,ruleValue:r}=this,a=t[e],s=t[r];null!=a&&a!==s&&(this.error=`${e} should be equal to ${r}.`)}}class c extends t{constructor({attributeName:t,attributes:e,translations:r}){super({attributeName:t,attributes:e,ruleName:"string",translations:r})}validate(){const t=this.attributeName;"string"!=typeof this.attributes[t]&&(this.error=`${t} should be a string.`)}}exports.Validator=class{constructor(t){this.rules=t,this.translations={}}setTranslations(t){this.translations=t}validate(t){const{translations:m}=this,h=Object.entries(this.rules).reduce(((h,[N,d])=>{const g=d.split("|").map((t=>t.trim())).reduce(((h,d)=>{const g=new l({attributeName:N,attributes:t,translations:m});if(g.match(d)&&g.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],g.getError()]});const p=new i({attributeName:N,attributes:t,translations:m});if(p.match(d)&&p.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],p.getError()]});const j=new a({attributeName:N,attributes:t,translations:m});if(j.match(d)&&j.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],j.getError()]});const O=new o({attributeName:N,attributes:t,translations:m});if(O.match(d)&&O.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],O.getError()]});const f=new e({attributeName:N,attributes:t,translations:m});if(f.match(d)&&f.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],f.getError()]});const E=new c({attributeName:N,attributes:t,translations:m});if(E.match(d)&&E.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],E.getError()]});const v=new b({attributeName:N,attributes:t,translations:m});if(v.match(d)&&v.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],v.getError()]});const $=new r({attributeName:N,attributes:t,translations:m});if($.match(d)&&$.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],$.getError()]});const w=new u({attributeName:N,attributes:t,translations:m});if(w.match(d)&&w.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],w.getError()]});const x=new n({attributeName:N,attributes:t,translations:m});if(x.match(d)&&x.hasError())return Object.assign(Object.assign({},h),{[N]:[...h[N]||[],x.getError()]});const y=new s({attributeName:N,attributes:t,translations:m});return y.match(d)&&y.hasError()?Object.assign(Object.assign({},h),{[N]:[...h[N]||[],y.getError()]}):h}),{});return Object.assign(Object.assign({},h),g)}),{});return 0===Object.keys(h).length?null:h}};
